{{ GRAMEX(cache=['parliament.csv', 'pc.csv', 'pc-latlong.csv', 'colors.csv', 'abbr.csv'], max_age=10*60) }}{% code %}
title = 'Lok Sabha elections cartogram'

import json
from urllib import quote
from common import pc_setup, slug, metric_names, NONE_COLOR

groupbys = ['PARTY', '2014 Schedule', '2014 Star Candidate']

data, elections = DB.csv('parliament.csv', setup=pc_setup, dtype=object)
latlong = DB.csv('pc-latlong.csv').set_index(['STATE', 'PC'])
groupby = args.get('BY', ['PARTY'])[0]
colors = DB.csv('colors.csv').set_index(['Field', 'Name'])['Color']
abbr = DB.csv('abbr.csv').set_index(['Field', 'Name'])['Abbr'].ix['STATE']

winners = data[data['#'] == '1']
elections['CONSTANT'] = 1
metric = 'CONSTANT' if groupby.startswith('2014') else args.get('METRIC', ['CONSTANT'])[0]

# Add constituency related metrics
constituencies = DB.csv('pc.csv')
constituencies['YEAR'] = '2009'
constituencies = constituencies.set_index(['YEAR', 'STATE', 'PC'])
elections[['2014 Schedule', '2014 Star Candidate']] = constituencies[['2014 Schedule', '2014 Star Candidate']]

years = sorted(data['YEAR'].unique())
year = '2009' if groupby.startswith('2014') else args.get('YEAR', years)[-1]
year_index = years.index(year)
prev_year = years[year_index - 1] if year_index > 0 else None
next_year = years[year_index + 1] if year_index < len(years) - 1 else None

chosen_states = args.get('STATE', [])

pivot = elections.ix[year][[groupby, 'WINNER', metric]]
if chosen_states:
    pivot = pivot.ix[chosen_states]
metric_mean = pivot[metric].mean()

win_count = pivot[groupby].value_counts()
max_wins = float(win_count.max())

W, H, R = 940, 700, 6
bar_height = 33
top_groups = win_count.head(min(20, H // bar_height))

# Eventually, don't hard-code it
if groupby == '2014 Schedule':
    top_groups = top_groups.ix[['07-Apr', '09-Apr', '10-Apr', '12-Apr', '17-Apr', '24-Apr', '30-Apr', '07-May', '12-May', ]].dropna().astype(int)

states = [''] + sorted(elections.ix[year].reset_index()['STATE'].unique())

if groupby in colors.index:
    colors = colors.ix[groupby]
else:
    colors = pd.Series(dict(zip(top_groups.index, _color.distinct(20 if len(top_groups) > 10 else 10))))

TOPH = 25
{% end %}

{% if metric != 'CONSTANT' %}
  <div class="row carto-summary">
    {% for name, table in [('Highest', pivot.fillna(0).sort(metric, ascending=False)), ('Lowest', pivot.fillna(0).sort(metric, ascending=True))] %}
      <div class="col-sm-6">
        <h3>{{ name }} {{ metric_names[metric] }} <small>{{ year }}</small></h3>
        <table class="table table-condensed table-striped">
          <thead><tr><th>State</th><th>PC</th><th>{{ groupby.title() }}</th><th>Winner</th><th>{{ metric_names[metric] }}</th></tr></thead>
          <tbody>
            {% for (state, pc), row in table.head(5).iterrows() %}
              {% set fill = colors.get(row[groupby], NONE_COLOR) %}
              <tr class="direct" href="result?BY=&YEAR={{ quote(year) }}&STATE={{ quote(state) }}&PC={{ quote(pc) }}">
                <td>{{ escape(state.title()) }}</td>
                <td>{{ escape(pc.title()) }}</td>
                <td style="background-color:{{ fill }};color:{{ _color.contrast(fill) }}">{{ escape(row[groupby]) }}</td>
                <td>{{ escape(row['WINNER'].title()) }}</td>
                <td>{{ ('{:,.1%}' if metric.endswith('%') else '{:,.0f}').format(row[metric]) }}</td>
              </tr>
            {% end %}
          </tbody>
        </table>
      </div>
    {% end %}
  </div>
{% end %}

<svg id="state-legend" width="100%" data-height="{{ float(TOPH * 2) / W }}" viewBox ="0 0 {{ W }} {{ TOPH * 2 }}">
  {% set w = W / float(len(states)) %}
  {% for i, state in enumerate(states) %}
    <g{% if state %} data-grp="{{ state }}"{% end %}>
      <rect class="state-legend"
        href="?STATE={{ quote(state) }}"
        x="{{ w * i }}"
        width="{{ w }}"
        height="{{ TOPH }}"
        title="{{ escape(state or 'All states') }}"
        fill="{{ '#e66' if not state else '#aec7e8' if state in chosen_states else '#f8f8f8' }}"/>
      <text x="{{ w * (i + .5) }}" y="{{ TOPH / 2 }}" text-anchor="middle" dy=".35em" font-size="12">{{ abbr.get(state, state) or 'X' }}</text>
      <text class="value" x="{{ w * (i + .5) }}" y="{{ TOPH + TOPH / 2 }}" text-anchor="middle" dy=".35em" font-size="14"></text>
    </g>
  {% end %}
</svg>

{% if metric != 'CONSTANT' %}
  <div class="row">
    {% set R_hi = 6 if pd.isnull(metric_mean) else R * (pivot[metric].max() / metric_mean) ** .5 %}
    <div class="col-xs-6"><input class="lo" type="range" min="0" max="{{ R_hi }}" step="0.1" value="0"></div>
    <div class="col-xs-6"><input class="hi" type="range" min="0" max="{{ R_hi }}" step="0.1" value="{{ R_hi }}"></div>
  </div>
{% end %}


<svg class="cartogram" width="100%" data-height="{{ float(H) / W }}" viewBox ="0 0 {{ W }} {{ H }}">
  <g id="carto-contents">
    <image x="-170" y="-5" width="{{ W }}" height="{{ H - 10 }}" xlink:href="{{ static_url('img/india-states.png') }}"></image>
    <g transform="translate(640,30)">
      {% if len(chosen_states) %}
        <text font-size="28" dy="-.2em" href="state?YEAR=&{{ '&'.join('STATE=' + quote(state) for state in chosen_states) }}">
          {{ ', '.join(chosen_states) }}
          <tspan class="small" fill="#888">{{ win_count.sum() }}</tspan> &raquo;
        </text>
      {% end %}
      <rect class="party-unhighlight" x="273" y="-24" width="22" height="20" fill="#e66" stroke="rgba(0,0,0,.4)" title="Clear selections"/>
      <text x="284" y="-14" text-anchor="middle" dy=".37em">X</text>
      {% for i, (group, wins) in enumerate(top_groups.iteritems()) %}
        {% set fill = colors.get(group, 'rgba(128,128,128,.5)') %}
        <rect x="-5" y="{{ i * bar_height }}" width="305" height="{{ bar_height }}"
          fill="#fff"
          class="party-legend bar-legend"
          data-highlight="[data-party={{ slug(group) }}]"
          data-party="{{ slug(group) }}"
          data-toggle="1"
        />
        <rect class="no-pointer" width="65" y="{{ i * bar_height + 5 }}" height="{{ bar_height - 10 }}" fill="{{ fill }}"/>
        <text x="5" y="{{ (i + .5) * bar_height }}" dy=".35em" font-size="{{ bar_height / 2 }}" fill="{{ _color.contrast(fill) }}">{{ group }}</text>
        <text x="100" y="{{ (i + .5) * bar_height }}" dy=".35em" text-anchor="end" font-size="{{ bar_height / 2 }}">{{ wins }}</text>
        <rect class="no-pointer" x="110" y="{{ (i + .5) * bar_height - bar_height / 2 + 5 }}" height="{{ bar_height - 10 }}" width="{{ 185 * wins / max_wins }}" fill="{{ fill }}"/>
      {% end %}
    </g>
  </g>
</svg>

{% code %}
pivot['Lat'] = latlong['Lat']
pivot['Long'] = latlong['Long']
{% end %}
<script id="data" type="text/csv">{% code %}
csv = StringIO()
pivot.to_csv(csv)
{% end %}{{ csv.getvalue() }}</script>
<script>
var colors = {{ json.dumps(colors.to_dict()) }},
    groupby = '{{ groupby }}',
    R = {{ R }}

var data = d3.csv.parse($('#data').text(), function(row) {
  for (var key in row) {
    // Convert values to integers
    if (key != 'STATE' && key != 'PC' && key != groupby)
      row[key] = +row[key]
    // Get the scaled x,y coords
    row.x = {{ H }} * .95 * (row['Long'] - 68.5) / (97 - 68.5) + Math.random() + {{ (W - H)/2 }} - 150,
    row.y = {{ H }} * (36.7 - row['Lat']) / (36.7 - 8) + Math.random(),
    {% if pd.isnull(metric_mean) %}
      row.r = R
    {% else %}
      row.r = R * Math.pow(row['{{ metric }}'] / {{ metric_mean }}, .5)
    {% end %}
  }
  return row
})

var update = d3.select('#carto-contents').selectAll('circle')
    .data(data)
  .enter()
    .append('circle')
    .attr('r', function(d) { return d.r })
    .attr('title', function(d) { return d.STATE + ': ' + d.PC + '<br>' + d[groupby] })
    .attr('fill', function(d, i) { return colors[d[groupby]] || 'rgba(128,128,128,.5)' })
    .attr('data-party', function(d) { return d[groupby].replace(/[^A-Za-z0-9_]/g, '-') })
    .attr('href', function(d) { return 'result?BY=&YEAR={{ year }}&STATE=' + encodeURIComponent(d.STATE) + '&PC=' + encodeURIComponent(d.PC) })
    .attr('stroke', 'rgba(0,0,0,.3)')
    .classed('direct', true)
    .call(G.unpack()
      .width({{ H }})
      .height({{ H }}))

var $lo = d3.select('input.lo'),
    $hi = d3.select('input.hi')

d3.selectAll('input[type="range"]').on('change', function() {
  var lo = DB.lo = +$lo.property('value'),
      hi = DB.hi = +$hi.property('value')
  update
    .classed('hide', function(d) { return (d.r < lo) || (d.r > hi) })
})

if (DB.lo && $lo.node()) $lo.property('value', DB.lo).on('change')()
if (DB.hi && $hi.node()) $hi.property('value', DB.hi).on('change')()

var statemap = $('[data-grp]').map(function() {
  var $this = d3.select(this)
  return {
    rect: $this.select('rect'),
    text: $this.select('text.value'),
    state: $this.attr('data-grp')
  }
}).get()

window.on_highlight = function(e) {
  var count = {},
      i=0,
      cell, match
  e.highlighted.each(function() {
    var row = this.__data__
    if (row) count[row.STATE] = (count[row.STATE] || 0) + 1
  })
  for (; cell=statemap[i]; i++) {
    match = cell.state in count
    cell.text.text(match ? count[cell.state] : '')
    cell.rect.classed('match', match)
  }
}
</script>
